<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.software.companion_device_setup&quot; /&gt;&#10;    &lt;!--  Request the general foreground service permission  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;!--  Request the specific foreground service permission for each declared type  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE&quot; /&gt;&#10;&#10;    &lt;!--  Request notification permission to be able to show the foreground service notification  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;&#10;    &lt;!--  Request location permission to be able to use the location foreground service type  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_CONNECT&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND&quot;/&gt;&#10;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.CameraGps&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.CameraGps&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.LogViewerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Log Viewer&quot;&#10;            android:theme=&quot;@style/Theme.CameraGps&quot;&#10;        /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.saschl.cameragps.service.CompanionDeviceSampleService&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:permission=&quot;android.permission.BIND_COMPANION_DEVICE_SERVICE&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.companion.CompanionDeviceService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.service.LocationSenderService&quot;&#10;            android:foregroundServiceType=&quot;location|connectedDevice&quot;&gt;&#10;        &lt;/service&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.software.companion_device_setup&quot; /&gt;&#10;    &lt;!--  Request the general foreground service permission  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;!--  Request the specific foreground service permission for each declared type  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE&quot; /&gt;&#10;&#10;    &lt;!--  Request notification permission to be able to show the foreground service notification  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;&#10;    &lt;!--  Request location permission to be able to use the location foreground service type  --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;&#10;    &lt;!-- Bluetooth permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_CONNECT&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_SCAN&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADVERTISE&quot; /&gt;&#10;    &#10;    &lt;!-- Companion device permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_RUN_IN_BACKGROUND&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_COMPANION_USE_DATA_IN_BACKGROUND&quot;/&gt;&#10;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.CameraGps&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.CameraGps&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.LogViewerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:label=&quot;Log Viewer&quot;&#10;            android:theme=&quot;@style/Theme.CameraGps&quot;&#10;        /&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;com.saschl.cameragps.service.CompanionDeviceSampleService&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:permission=&quot;android.permission.BIND_COMPANION_DEVICE_SERVICE&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.companion.CompanionDeviceService&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.service.LocationSenderService&quot;&#10;            android:foregroundServiceType=&quot;location|connectedDevice&quot;&gt;&#10;        &lt;/service&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/saschl/cameragps/service/CompanionDeviceManagerSample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/saschl/cameragps/service/CompanionDeviceManagerSample.kt" />
              <option name="originalContent" value="/*&#10; * Copyright 2023 The Android Open Source Project&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10; * you may not use this file except in compliance with the License.&#10; * You may obtain a copy of the License at&#10; *&#10; *     https://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10; * See the License for the specific language governing permissions and&#10; * limitations under the License.&#10; */&#10;&#10;package com.saschl.cameragps.service&#10;&#10;import android.Manifest&#10;import android.bluetooth.BluetoothAdapter&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothDevice.TRANSPORT_AUTO&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothGattService&#10;import android.bluetooth.BluetoothManager&#10;import android.bluetooth.BluetoothProfile&#10;import android.bluetooth.le.ScanResult&#10;import android.companion.AssociationInfo&#10;import android.companion.AssociationRequest&#10;import android.companion.BluetoothLeDeviceFilter&#10;import android.companion.CompanionDeviceManager&#10;import android.companion.ObservingDevicePresenceRequest&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.IntentSender&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.IntentSenderRequest&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.SolidColor&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.getSystemService&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.LifecycleOwner&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.saschl.cameragps.R&#10;import com.saschl.cameragps.service.AssociatedDeviceCompat&#10;import com.saschl.cameragps.service.getAssociatedDevices&#10;import com.saschl.cameragps.service.toAssociatedDevice&#10;import com.saschl.cameragps.ui.EnhancedLocationPermissionBox&#10;import com.saschl.cameragps.ui.LogViewerActivity&#10;import com.saschl.cameragps.service.CompanionDeviceSampleService.Companion.CHARACTERISTIC_UUID&#10;import com.saschl.cameragps.service.CompanionDeviceSampleService.Companion.SERVICE_UUID&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import java.nio.ByteBuffer&#10;import java.time.Instant&#10;import java.time.ZoneId&#10;import java.time.ZonedDateTime&#10;import java.util.concurrent.Executor&#10;import java.util.regex.Pattern&#10;import kotlin.random.Random&#10;&#10;@Composable&#10;fun CompanionDeviceManagerSample() {&#10;&#10;    val context = LocalContext.current&#10;    val deviceManager = context.getSystemService&lt;CompanionDeviceManager&gt;()&#10;    val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;    var selectedDevice by remember {&#10;        mutableStateOf&lt;BluetoothDevice?&gt;(null)&#10;    }&#10;    if (deviceManager == null || adapter == null) {&#10;        Text(text = &quot;No Companion device manager found. The device does not support it.&quot;)&#10;    } else {&#10;        if (selectedDevice == null) {&#10;            EnhancedLocationPermissionBox {&#10;                DevicesScreen(deviceManager) { device -&gt;&#10;                    selectedDevice =&#10;                        (device.device ?: adapter.getRemoteDevice(device.address))&#10;                }&#10;            }&#10;        } else {&#10;            EnhancedLocationPermissionBox {&#10;                ConnectDeviceScreen(device = selectedDevice!!) {&#10;                    selectedDevice = null&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;private data class DeviceConnectionState(&#10;    val gatt: BluetoothGatt?,&#10;    val connectionState: Int,&#10;    val mtu: Int,&#10;    val services: List&lt;BluetoothGattService&gt; = emptyList(),&#10;    val messageSent: Boolean = false,&#10;    val messageReceived: String = &quot;&quot;,&#10;) {&#10;    companion object {&#10;        val None = DeviceConnectionState(null, -1, -1)&#10;    }&#10;}&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;private fun BLEConnectEffect(&#10;    device: BluetoothDevice,&#10;    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,&#10;    onStateChange: (DeviceConnectionState) -&gt; Unit,&#10;) {&#10;    val context = LocalContext.current&#10;    val currentOnStateChange by rememberUpdatedState(onStateChange)&#10;&#10;    // Keep the current connection state&#10;    var state by remember {&#10;        mutableStateOf(DeviceConnectionState.None)&#10;    }&#10;&#10;    DisposableEffect(lifecycleOwner, device) {&#10;        // This callback will notify us when things change in the GATT connection so we can update&#10;        // our state&#10;        val callback = object : BluetoothGattCallback() {&#10;            override fun onConnectionStateChange(&#10;                gatt: BluetoothGatt,&#10;                status: Int,&#10;                newState: Int,&#10;            ) {&#10;                super.onConnectionStateChange(gatt, status, newState)&#10;                state = state.copy(gatt = gatt, connectionState = newState)&#10;                currentOnStateChange(state)&#10;&#10;                if (status != BluetoothGatt.GATT_SUCCESS) {&#10;                    // Here you should handle the error returned in status based on the constants&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothGatt#summary&#10;                    // For example for GATT_INSUFFICIENT_ENCRYPTION or&#10;                    // GATT_INSUFFICIENT_AUTHENTICATION you should create a bond.&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createBond()&#10;                    Log.e(&quot;BLEConnectEffect&quot;, &quot;An error happened: $status&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {&#10;                super.onMtuChanged(gatt, mtu, status)&#10;                state = state.copy(gatt = gatt, mtu = mtu)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;                super.onServicesDiscovered(gatt, status)&#10;                state = state.copy(services = gatt.services)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onCharacteristicWrite(&#10;                gatt: BluetoothGatt?,&#10;                characteristic: BluetoothGattCharacteristic?,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicWrite(gatt, characteristic, status)&#10;                state = state.copy(messageSent = status == BluetoothGatt.GATT_SUCCESS)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            @Suppress(&quot;DEPRECATION&quot;, &quot;OVERRIDE_DEPRECATION&quot;)&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, status)&#10;                //   if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;                doOnRead(characteristic.value)&#10;                //    }&#10;            }&#10;&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                value: ByteArray,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, value, status)&#10;                doOnRead(value)&#10;            }&#10;&#10;            private fun doOnRead(value: ByteArray) {&#10;                state = state.copy(messageReceived = value.decodeToString())&#10;                currentOnStateChange(state)&#10;            }&#10;        }&#10;&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_START) {&#10;                if (state.gatt != null) {&#10;                    // If we previously had a GATT connection let's reestablish it&#10;                    state.gatt?.connect()&#10;                } else {&#10;                    // Otherwise create a new GATT connection&#10;                    state = state.copy(&#10;                        gatt = device.connectGatt(&#10;                            context,&#10;                            false,&#10;                            callback,&#10;                            TRANSPORT_AUTO&#10;                        )&#10;                    )&#10;                }&#10;            } else if (event == Lifecycle.Event.ON_STOP) {&#10;                // Unless you have a reason to keep connected while in the bg you should disconnect&#10;                state.gatt?.disconnect()&#10;            }&#10;        }&#10;&#10;        // Add the observer to the lifecycle&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;        // When the effect leaves the Composition, remove the observer and close the connection&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;            state.gatt?.close()&#10;            state = DeviceConnectionState.None&#10;        }&#10;    }&#10;}&#10;&#10;internal fun Int.toConnectionStateString() = when (this) {&#10;    BluetoothProfile.STATE_CONNECTED -&gt; &quot;Connected&quot;&#10;    BluetoothProfile.STATE_CONNECTING -&gt; &quot;Connecting&quot;&#10;    BluetoothProfile.STATE_DISCONNECTED -&gt; &quot;Disconnected&quot;&#10;    BluetoothProfile.STATE_DISCONNECTING -&gt; &quot;Disconnecting&quot;&#10;    else -&gt; &quot;N/A&quot;&#10;}&#10;&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;fun ConnectDeviceScreen(device: BluetoothDevice, onClose: () -&gt; Unit) {&#10;    val scope = rememberCoroutineScope()&#10;    val context = LocalContext.current&#10;&#10;    // Keeps track of the last connection state with the device&#10;    var state by remember(device) {&#10;        mutableStateOf&lt;DeviceConnectionState?&gt;(null)&#10;    }&#10;&#10;    // Track Bluetooth pairing state&#10;    var pairingState by remember(device) {&#10;        mutableStateOf(BluetoothPairingState())&#10;    }&#10;&#10;    // Once the device services are discovered find the GATTServerSample service&#10;    val service by remember(state) {&#10;        mutableStateOf(state?.services?.find { it.uuid == SERVICE_UUID })&#10;    }&#10;    // If the GATTServerSample service is found, get the characteristic&#10;    val characteristic by remember(service) {&#10;        mutableStateOf(service?.getCharacteristic(CHARACTERISTIC_UUID))&#10;    }&#10;&#10;    // Handle Bluetooth pairing&#10;    BluetoothPairingEffect(&#10;        device = device,&#10;        onPairingStateChange = { newPairingState -&gt;&#10;            pairingState = newPairingState&#10;        }&#10;    )&#10;&#10;    // This effect will handle the connection and notify when the state changes&#10;    BLEConnectEffect(device = device) {&#10;        // update our state to recompose the UI&#10;        state = it&#10;&#10;        // If we get authentication/encryption errors, try to pair the device&#10;        if (it.gatt != null) {&#10;            // Check if we need to pair the device&#10;            val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;            if (!isDevicePaired(adapter, device.address) &amp;&amp; pairingState.state != PairingState.PAIRING) {&#10;                Timber.i(&quot;Device not paired, initiating pairing process&quot;)&#10;                scope.launch {&#10;                    initiateBluetoothPairing(device)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        Text(text = &quot;Device Details&quot;, style = MaterialTheme.typography.headlineSmall)&#10;        Text(text = &quot;Name: ${device.name} (${device.address})&quot;)&#10;&#10;        // Show pairing status&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(text = &quot;Pairing Status:&quot;)&#10;            Text(&#10;                text = when (pairingState.state) {&#10;                    PairingState.NOT_PAIRED -&gt; &quot;Not Paired&quot;&#10;                    PairingState.PAIRING -&gt; &quot;Pairing...&quot;&#10;                    PairingState.PAIRED -&gt; &quot;Paired âœ“&quot;&#10;                    PairingState.PAIRING_FAILED -&gt; &quot;Failed&quot;&#10;                },&#10;                color = when (pairingState.state) {&#10;                    PairingState.PAIRED -&gt; MaterialTheme.colorScheme.primary&#10;                    PairingState.PAIRING_FAILED -&gt; MaterialTheme.colorScheme.error&#10;                    else -&gt; MaterialTheme.colorScheme.onSurface&#10;                }&#10;            )&#10;        }&#10;&#10;        // Show pairing error if any&#10;        pairingState.errorMessage?.let { error -&gt;&#10;            Text(&#10;                text = &quot;Pairing Error: $error&quot;,&#10;                color = MaterialTheme.colorScheme.error,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;        }&#10;&#10;        Text(text = &quot;Connection Status: ${state?.connectionState?.toConnectionStateString()}&quot;)&#10;        Text(text = &quot;MTU: ${state?.mtu}&quot;)&#10;        Text(text = &quot;Services: ${state?.services?.joinToString { it.uuid.toString() + &quot; &quot; + it.type }}&quot;)&#10;        Text(text = &quot;Message sent: ${state?.messageSent}&quot;)&#10;        Text(text = &quot;Message received: ${state?.messageReceived}&quot;)&#10;&#10;        // Manual pairing button&#10;        Button(&#10;            enabled = pairingState.state == PairingState.NOT_PAIRED || pairingState.state == PairingState.PAIRING_FAILED,&#10;            onClick = {&#10;                scope.launch {&#10;                    Timber.i(&quot;Manual pairing initiated for ${device.name}&quot;)&#10;                    initiateBluetoothPairing(device)&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = if (pairingState.state == PairingState.PAIRING) &quot;Pairing...&quot; else &quot;Pair Device&quot;)&#10;        }&#10;        Button(&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    if (state?.connectionState == BluetoothProfile.STATE_DISCONNECTED) {&#10;                        //      state?.gatt?.connect()&#10;                    }&#10;                    // Example on how to request specific MTUs&#10;                    // Note that from Android 14 onwards the system will define a default MTU and&#10;                    // it will only be sent once to the peripheral device&#10;                    state?.gatt?.requestMtu(Random.nextInt(27, 190))&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Request MTU&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    // Once we have the connection discover the peripheral services&#10;                    state?.gatt?.discoverServices()&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Discover&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                /* scope.launch(Dispatchers.IO) {&#10;                     sendData(state?.gatt!!, characteristic!!)&#10;                 }*/&#10;            },&#10;        ) {&#10;            Text(text = &quot;Write to server&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    state?.gatt?.readCharacteristic(characteristic)&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Read characteristic&quot;)&#10;        }&#10;        Button(onClick = onClose) {&#10;            Text(text = &quot;Close&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;fun set_location(latitude: Double, longitude: Double): ByteArray {&#10;    val myLat = (latitude * 1e7).toInt()&#10;    val myLng = (longitude * 1e7).toInt()&#10;    val myLatByte = ByteBuffer.allocate(4).putInt(myLat).array()&#10;    val myLngByte = ByteBuffer.allocate(4).putInt(myLng).array()&#10;    return myLatByte + myLngByte&#10;}&#10;&#10;fun set_date(zoneId: ZoneId): ByteArray {&#10;    val now = ZonedDateTime.ofInstant(Instant.now(), zoneId)&#10;    val year = now.year.toShort()&#10;    val yearBytes = ByteBuffer.allocate(2).putShort(year).array()&#10;    val hour = now.hour&#10;    return byteArrayOf(&#10;        yearBytes[0], yearBytes[1],&#10;        now.monthValue.toByte(),&#10;        now.dayOfMonth.toByte(),&#10;        now.hour.toByte(),&#10;        now.minute.toByte(),&#10;        now.second.toByte()&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;private fun DevicesScreen(&#10;    deviceManager: CompanionDeviceManager,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val context = LocalContext.current&#10;    var associatedDevices by remember {&#10;        // If we already associated the device no need to do it again.&#10;        mutableStateOf(deviceManager.getAssociatedDevices())&#10;    }&#10;&#10;        LaunchedEffect(associatedDevices) {&#10;            associatedDevices.forEach {&#10;                Timber.i(&quot;Starting observing device presence for ${it.name} (${it.address})&quot;)&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.BAKLAVA) {&#10;                    deviceManager.startObservingDevicePresence(ObservingDevicePresenceRequest.Builder().setAssociationId(it.id).build())&#10;                } else {&#10;                    deviceManager.startObservingDevicePresence(it.address)&#10;                }&#10;            }&#10;&#10;        }&#10;&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            Text(&#10;                text = &quot;Sony Camera GPS&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(32.dp),&#10;            )&#10;        }) { innerPadding -&gt;&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(innerPadding),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;&#10;        ) {&#10;            Button(onClick = {&#10;                context.startActivity(&#10;                    Intent(&#10;                        context,&#10;                        LogViewerActivity::class.java&#10;                    )&#10;                )&#10;            }) { Text(text = &quot;View logs&quot;) }&#10;            ScanForDevicesMenu(deviceManager) {&#10;                associatedDevices = associatedDevices + it&#10;            }&#10;            AssociatedDevicesList(&#10;                associatedDevices = associatedDevices,&#10;                onConnect = onConnect,&#10;                onDisassociate = {&#10;                    scope.launch {&#10;&#10;                        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.BAKLAVA) {&#10;                            deviceManager.stopObservingDevicePresence(&#10;                                ObservingDevicePresenceRequest.Builder().setAssociationId(it.id)&#10;                                    .build()&#10;                            )&#10;&#10;                        } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                            @Suppress(&quot;DEPRECATION&quot;)&#10;                            deviceManager.stopObservingDevicePresence(it.address)&#10;                        }&#10;&#10;                        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                            deviceManager.disassociate(it.id)&#10;                        } else {&#10;                            @Suppress(&quot;DEPRECATION&quot;)&#10;                            deviceManager.disassociate(it.address)&#10;                        }&#10;&#10;&#10;                        associatedDevices = deviceManager.getAssociatedDevices()&#10;                    }&#10;                },&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ScanForDevicesMenu(&#10;    deviceManager: CompanionDeviceManager,&#10;    onDeviceAssociated: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var errorMessage by remember {&#10;        mutableStateOf(&quot;&quot;)&#10;    }&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartIntentSenderForResult(),&#10;    ) {&#10;        when (it.resultCode) {&#10;            CompanionDeviceManager.RESULT_OK -&gt; {&#10;                it.data?.getAssociationResult()?.run {&#10;                    onDeviceAssociated(this)&#10;                }&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_CANCELED -&gt; {&#10;                errorMessage = &quot;The request was canceled&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_INTERNAL_ERROR -&gt; {&#10;                errorMessage = &quot;Internal error happened&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_DISCOVERY_TIMEOUT -&gt; {&#10;                errorMessage = &quot;No device matching the given filter were found&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_USER_REJECTED -&gt; {&#10;                errorMessage = &quot;The user explicitly declined the request&quot;&#10;            }&#10;&#10;            else -&gt; {&#10;                errorMessage = &quot;Unknown error&quot;&#10;            }&#10;        }&#10;    }&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(MaterialTheme.colorScheme.primaryContainer)&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;    ) {&#10;        Row {&#10;            Text(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f),&#10;                text = stringResource(R.string.scan_for_devices),&#10;            )&#10;            Button(&#10;                modifier = Modifier.weight(0.3f),&#10;                onClick = {&#10;                    scope.launch {&#10;                        val intentSender = requestDeviceAssociation(deviceManager)&#10;                        launcher.launch(IntentSenderRequest.Builder(intentSender).build())&#10;                    }&#10;                },&#10;            ) {&#10;                Text(text = &quot;Start&quot;)&#10;            }&#10;        }&#10;        if (errorMessage.isNotBlank()) {&#10;            Text(text = errorMessage, color = MaterialTheme.colorScheme.error)&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;private fun AssociatedDevicesList(&#10;    associatedDevices: List&lt;AssociatedDeviceCompat&gt;,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;    onDisassociate: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        stickyHeader {&#10;            Text(&#10;                text = &quot;Associated Devices:&quot;,&#10;                modifier = Modifier.padding(vertical = 8.dp),&#10;                style = MaterialTheme.typography.titleMedium,&#10;            )&#10;        }&#10;        items(associatedDevices) { device -&gt;&#10;            Row(&#10;                Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically,&#10;            ) {&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(1f),&#10;                ) {&#10;                    Text(text = &quot;ID: ${device.id}&quot;)&#10;                    Text(text = &quot;MAC: ${device.address}&quot;)&#10;                    Text(text = &quot;Name: ${device.name}&quot;)&#10;                }&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(0.6f),&#10;                    horizontalAlignment = Alignment.End,&#10;                    verticalArrangement = Arrangement.Center,&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = { onConnect(device) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                    ) {&#10;                        Text(text = &quot;Connect&quot;)&#10;                    }&#10;                    OutlinedButton(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        onClick = { onDisassociate(device) },&#10;                        border = ButtonDefaults.outlinedButtonBorder().copy(&#10;                            brush = SolidColor(MaterialTheme.colorScheme.error),&#10;                        ),&#10;                    ) {&#10;                        Text(text = &quot;Disassociate&quot;, color = MaterialTheme.colorScheme.error)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun Intent.getAssociationResult(): AssociatedDeviceCompat? {&#10;    var result: AssociatedDeviceCompat? = null&#10;&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;        result = getParcelableExtra(&#10;            CompanionDeviceManager.EXTRA_ASSOCIATION,&#10;            AssociationInfo::class.java,&#10;        )?.toAssociatedDevice()&#10;    } else {&#10;        // Below Android 33 the result returns either a BLE ScanResult, a&#10;        // Classic BluetoothDevice or a Wifi ScanResult&#10;        // In our case we are looking for our BLE GATT server so we can cast directly&#10;        // to the BLE ScanResult&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        val scanResult = getParcelableExtra&lt;ScanResult&gt;(CompanionDeviceManager.EXTRA_DEVICE)&#10;        if (scanResult != null) {&#10;            result = AssociatedDeviceCompat(&#10;                id = scanResult.advertisingSid,&#10;                address = scanResult.device.address ?: &quot;N/A&quot;,&#10;                name = scanResult.scanRecord?.deviceName ?: &quot;N/A&quot;,&#10;                device = scanResult.device,&#10;            )&#10;        }&#10;    }&#10;    return result&#10;&#10;}&#10;&#10;private suspend fun requestDeviceAssociation(deviceManager: CompanionDeviceManager): IntentSender {&#10;    // Match only Bluetooth devices whose service UUID matches this pattern.&#10;    // For this demo we will match our GATTServerSample&#10;    val deviceFilter = BluetoothLeDeviceFilter.Builder()&#10;        .setNamePattern(Pattern.compile(&quot;ILCE&quot;))&#10;        .build()&#10;&#10;    val pairingRequest: AssociationRequest = AssociationRequest.Builder()&#10;        // Find only devices that match this request filter.&#10;        .addDeviceFilter(deviceFilter)&#10;        // Stop scanning as soon as one device matching the filter is found.&#10;      //  .setSingleDevice(true)&#10;        .build()&#10;&#10;    val result = CompletableDeferred&lt;IntentSender&gt;()&#10;&#10;    val callback = object : CompanionDeviceManager.Callback() {&#10;        override fun onAssociationPending(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        @Suppress(&quot;OVERRIDE_DEPRECATION&quot;)&#10;        override fun onDeviceFound(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        override fun onAssociationCreated(associationInfo: AssociationInfo) {&#10;&#10;            Timber.i(&quot;Association created: ${associationInfo.displayName} (${associationInfo.id})&quot;)&#10;            // If you want to start observing the device presence you can do it here.&#10;            // This will allow you to receive events when the device is nearby or not.&#10;            // Note that this is only available in API 34 and above.&#10;        /*    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.BAKLAVA) {&#10;                deviceManager.startObservingDevicePresence(&#10;                    ObservingDevicePresenceRequest.Builder().setAssociationId(associationInfo.id)&#10;                        .build()&#10;                )&#10;            } else {&#10;                deviceManager.myAssociations.stream().filter { it -&gt; it.id == associationInfo. }&#10;                deviceManager.startOmyAssociationsbservingDevicePresence(it.toAssociatedDevice().address)&#10;            }*/&#10;            // This callback was added in API 33 but the result is also send in the activity result.&#10;            // For handling backwards compatibility we can just have all the logic there instead&#10;        }&#10;&#10;        override fun onFailure(errorMessage: CharSequence?) {&#10;            result.completeExceptionally(IllegalStateException(errorMessage?.toString().orEmpty()))&#10;        }&#10;    }&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;        val executor = Executor { it.run() }&#10;        deviceManager.associate(pairingRequest, executor, callback)&#10;    } else {&#10;        deviceManager.associate(pairingRequest, callback, null)&#10;    }&#10;&#10;    return result.await()&#10;}&#10;&#10;// Bluetooth pairing state and functionality&#10;enum class PairingState {&#10;    NOT_PAIRED,&#10;    PAIRING,&#10;    PAIRED,&#10;    PAIRING_FAILED&#10;}&#10;&#10;data class BluetoothPairingState(&#10;    val state: PairingState = PairingState.NOT_PAIRED,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;@RequiresPermission(allOf = [Manifest.permission.BLUETOOTH_CONNECT])&#10;fun isDevicePaired(adapter: BluetoothAdapter?, deviceAddress: String): Boolean {&#10;    return adapter?.bondedDevices?.any { it.address == deviceAddress } ?: false&#10;}&#10;&#10;@RequiresPermission(allOf = [Manifest.permission.BLUETOOTH_CONNECT])&#10;fun initiateBluetoothPairing(device: BluetoothDevice): Boolean {&#10;    return try {&#10;        device.createBond()&#10;    } catch (e: SecurityException) {&#10;        Timber.e(e, &quot;Failed to initiate pairing due to security exception&quot;)&#10;        false&#10;    } catch (e: Exception) {&#10;        Timber.e(e, &quot;Failed to initiate pairing&quot;)&#10;        false&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BluetoothPairingEffect(&#10;    device: BluetoothDevice,&#10;    onPairingStateChange: (BluetoothPairingState) -&gt; Unit,&#10;    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current&#10;) {&#10;    val context = LocalContext.current&#10;    val currentOnPairingStateChange by rememberUpdatedState(onPairingStateChange)&#10;&#10;    DisposableEffect(device, lifecycleOwner) {&#10;        var pairingState by mutableStateOf(BluetoothPairingState())&#10;&#10;        val pairingReceiver = object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                when (intent?.action) {&#10;                    BluetoothDevice.ACTION_BOND_STATE_CHANGED -&gt; {&#10;                        val bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE)&#10;                        val bondedDevice = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                            intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE, BluetoothDevice::class.java)&#10;                        } else {&#10;                            @Suppress(&quot;DEPRECATION&quot;)&#10;                            intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)&#10;                        }&#10;&#10;                        if (bondedDevice?.address == device.address) {&#10;                            when (bondState) {&#10;                                BluetoothDevice.BOND_BONDING -&gt; {&#10;                                    pairingState = BluetoothPairingState(PairingState.PAIRING)&#10;                                    currentOnPairingStateChange(pairingState)&#10;                                    Timber.i(&quot;Bluetooth pairing in progress with ${device.name}&quot;)&#10;                                }&#10;                                BluetoothDevice.BOND_BONDED -&gt; {&#10;                                    pairingState = BluetoothPairingState(PairingState.PAIRED)&#10;                                    currentOnPairingStateChange(pairingState)&#10;                                    Timber.i(&quot;Bluetooth pairing successful with ${device.name}&quot;)&#10;                                }&#10;                                BluetoothDevice.BOND_NONE -&gt; {&#10;                                    pairingState = BluetoothPairingState(&#10;                                        PairingState.PAIRING_FAILED,&#10;                                        &quot;Pairing failed or bond was removed&quot;&#10;                                    )&#10;                                    currentOnPairingStateChange(pairingState)&#10;                                    Timber.w(&quot;Bluetooth pairing failed with ${device.name}&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        val filter = IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED)&#10;        context.registerReceiver(pairingReceiver, filter)&#10;&#10;        // Check initial pairing state&#10;        val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;        val isAlreadyPaired = isDevicePaired(adapter, device.address)&#10;        if (isAlreadyPaired) {&#10;            pairingState = BluetoothPairingState(PairingState.PAIRED)&#10;            currentOnPairingStateChange(pairingState)&#10;        } else {&#10;            pairingState = BluetoothPairingState(PairingState.NOT_PAIRED)&#10;            currentOnPairingStateChange(pairingState)&#10;        }&#10;&#10;        onDispose {&#10;            context.unregisterReceiver(pairingReceiver)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/*&#10; * Copyright 2023 The Android Open Source Project&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);&#10; * you may not use this file except in compliance with the License.&#10; * You may obtain a copy of the License at&#10; *&#10; *     https://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&#10; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#10; * See the License for the specific language governing permissions and&#10; * limitations under the License.&#10; */&#10;&#10;package com.saschl.cameragps.service&#10;&#10;import android.Manifest&#10;import android.bluetooth.BluetoothAdapter&#10;import android.bluetooth.BluetoothDevice&#10;import android.bluetooth.BluetoothDevice.TRANSPORT_AUTO&#10;import android.bluetooth.BluetoothGatt&#10;import android.bluetooth.BluetoothGattCallback&#10;import android.bluetooth.BluetoothGattCharacteristic&#10;import android.bluetooth.BluetoothGattService&#10;import android.bluetooth.BluetoothManager&#10;import android.bluetooth.BluetoothProfile&#10;import android.bluetooth.le.ScanResult&#10;import android.companion.AssociationInfo&#10;import android.companion.AssociationRequest&#10;import android.companion.BluetoothLeDeviceFilter&#10;import android.companion.CompanionDeviceManager&#10;import android.companion.ObservingDevicePresenceRequest&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.IntentSender&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.IntentSenderRequest&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.rememberUpdatedState&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.SolidColor&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.getSystemService&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.LifecycleOwner&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import com.saschl.cameragps.R&#10;import com.saschl.cameragps.service.AssociatedDeviceCompat&#10;import com.saschl.cameragps.service.getAssociatedDevices&#10;import com.saschl.cameragps.service.toAssociatedDevice&#10;import com.saschl.cameragps.ui.EnhancedLocationPermissionBox&#10;import com.saschl.cameragps.ui.LogViewerActivity&#10;import com.saschl.cameragps.service.CompanionDeviceSampleService.Companion.CHARACTERISTIC_UUID&#10;import com.saschl.cameragps.service.CompanionDeviceSampleService.Companion.SERVICE_UUID&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import java.nio.ByteBuffer&#10;import java.time.Instant&#10;import java.time.ZoneId&#10;import java.time.ZonedDateTime&#10;import java.util.concurrent.Executor&#10;import java.util.regex.Pattern&#10;import kotlin.random.Random&#10;&#10;@Composable&#10;fun CompanionDeviceManagerSample() {&#10;&#10;    val context = LocalContext.current&#10;    val deviceManager = context.getSystemService&lt;CompanionDeviceManager&gt;()&#10;    val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;    var selectedDevice by remember {&#10;        mutableStateOf&lt;BluetoothDevice?&gt;(null)&#10;    }&#10;    if (deviceManager == null || adapter == null) {&#10;        Text(text = &quot;No Companion device manager found. The device does not support it.&quot;)&#10;    } else {&#10;        if (selectedDevice == null) {&#10;            EnhancedLocationPermissionBox {&#10;                DevicesScreen(deviceManager) { device -&gt;&#10;                    selectedDevice =&#10;                        (device.device ?: adapter.getRemoteDevice(device.address))&#10;                }&#10;            }&#10;        } else {&#10;            EnhancedLocationPermissionBox {&#10;                ConnectDeviceScreen(device = selectedDevice!!) {&#10;                    selectedDevice = null&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;private data class DeviceConnectionState(&#10;    val gatt: BluetoothGatt?,&#10;    val connectionState: Int,&#10;    val mtu: Int,&#10;    val services: List&lt;BluetoothGattService&gt; = emptyList(),&#10;    val messageSent: Boolean = false,&#10;    val messageReceived: String = &quot;&quot;,&#10;) {&#10;    companion object {&#10;        val None = DeviceConnectionState(null, -1, -1)&#10;    }&#10;}&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;private fun BLEConnectEffect(&#10;    device: BluetoothDevice,&#10;    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,&#10;    onStateChange: (DeviceConnectionState) -&gt; Unit,&#10;) {&#10;    val context = LocalContext.current&#10;    val currentOnStateChange by rememberUpdatedState(onStateChange)&#10;&#10;    // Keep the current connection state&#10;    var state by remember {&#10;        mutableStateOf(DeviceConnectionState.None)&#10;    }&#10;&#10;    DisposableEffect(lifecycleOwner, device) {&#10;        // This callback will notify us when things change in the GATT connection so we can update&#10;        // our state&#10;        val callback = object : BluetoothGattCallback() {&#10;            override fun onConnectionStateChange(&#10;                gatt: BluetoothGatt,&#10;                status: Int,&#10;                newState: Int,&#10;            ) {&#10;                super.onConnectionStateChange(gatt, status, newState)&#10;                state = state.copy(gatt = gatt, connectionState = newState)&#10;                currentOnStateChange(state)&#10;&#10;                if (status != BluetoothGatt.GATT_SUCCESS) {&#10;                    // Here you should handle the error returned in status based on the constants&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothGatt#summary&#10;                    // For example for GATT_INSUFFICIENT_ENCRYPTION or&#10;                    // GATT_INSUFFICIENT_AUTHENTICATION you should create a bond.&#10;                    // https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createBond()&#10;                    Log.e(&quot;BLEConnectEffect&quot;, &quot;An error happened: $status&quot;)&#10;                }&#10;            }&#10;&#10;            override fun onMtuChanged(gatt: BluetoothGatt, mtu: Int, status: Int) {&#10;                super.onMtuChanged(gatt, mtu, status)&#10;                state = state.copy(gatt = gatt, mtu = mtu)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {&#10;                super.onServicesDiscovered(gatt, status)&#10;                state = state.copy(services = gatt.services)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            override fun onCharacteristicWrite(&#10;                gatt: BluetoothGatt?,&#10;                characteristic: BluetoothGattCharacteristic?,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicWrite(gatt, characteristic, status)&#10;                state = state.copy(messageSent = status == BluetoothGatt.GATT_SUCCESS)&#10;                currentOnStateChange(state)&#10;            }&#10;&#10;            @Suppress(&quot;DEPRECATION&quot;, &quot;OVERRIDE_DEPRECATION&quot;)&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, status)&#10;                //   if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;                doOnRead(characteristic.value)&#10;                //    }&#10;            }&#10;&#10;            override fun onCharacteristicRead(&#10;                gatt: BluetoothGatt,&#10;                characteristic: BluetoothGattCharacteristic,&#10;                value: ByteArray,&#10;                status: Int,&#10;            ) {&#10;                super.onCharacteristicRead(gatt, characteristic, value, status)&#10;                doOnRead(value)&#10;            }&#10;&#10;            private fun doOnRead(value: ByteArray) {&#10;                state = state.copy(messageReceived = value.decodeToString())&#10;                currentOnStateChange(state)&#10;            }&#10;        }&#10;&#10;        val observer = LifecycleEventObserver { _, event -&gt;&#10;            if (event == Lifecycle.Event.ON_START) {&#10;                if (state.gatt != null) {&#10;                    // If we previously had a GATT connection let's reestablish it&#10;                    state.gatt?.connect()&#10;                } else {&#10;                    // Otherwise create a new GATT connection&#10;                    state = state.copy(&#10;                        gatt = device.connectGatt(&#10;                            context,&#10;                            false,&#10;                            callback,&#10;                            TRANSPORT_AUTO&#10;                        )&#10;                    )&#10;                }&#10;            } else if (event == Lifecycle.Event.ON_STOP) {&#10;                // Unless you have a reason to keep connected while in the bg you should disconnect&#10;                state.gatt?.disconnect()&#10;            }&#10;        }&#10;&#10;        // Add the observer to the lifecycle&#10;        lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;        // When the effect leaves the Composition, remove the observer and close the connection&#10;        onDispose {&#10;            lifecycleOwner.lifecycle.removeObserver(observer)&#10;            state.gatt?.close()&#10;            state = DeviceConnectionState.None&#10;        }&#10;    }&#10;}&#10;&#10;internal fun Int.toConnectionStateString() = when (this) {&#10;    BluetoothProfile.STATE_CONNECTED -&gt; &quot;Connected&quot;&#10;    BluetoothProfile.STATE_CONNECTING -&gt; &quot;Connecting&quot;&#10;    BluetoothProfile.STATE_DISCONNECTED -&gt; &quot;Disconnected&quot;&#10;    BluetoothProfile.STATE_DISCONNECTING -&gt; &quot;Disconnecting&quot;&#10;    else -&gt; &quot;N/A&quot;&#10;}&#10;&#10;&#10;@RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)&#10;@Composable&#10;fun ConnectDeviceScreen(device: BluetoothDevice, onClose: () -&gt; Unit) {&#10;    val scope = rememberCoroutineScope()&#10;    val context = LocalContext.current&#10;&#10;    // Keeps track of the last connection state with the device&#10;    var state by remember(device) {&#10;        mutableStateOf&lt;DeviceConnectionState?&gt;(null)&#10;    }&#10;&#10;    // Track Bluetooth pairing state&#10;    var pairingState by remember(device) {&#10;        mutableStateOf(BluetoothPairingState())&#10;    }&#10;&#10;    // Once the device services are discovered find the GATTServerSample service&#10;    val service by remember(state) {&#10;        mutableStateOf(state?.services?.find { it.uuid == SERVICE_UUID })&#10;    }&#10;    // If the GATTServerSample service is found, get the characteristic&#10;    val characteristic by remember(service) {&#10;        mutableStateOf(service?.getCharacteristic(CHARACTERISTIC_UUID))&#10;    }&#10;&#10;    // Handle Bluetooth pairing&#10;    BluetoothPairingEffect(&#10;        device = device,&#10;        onPairingStateChange = { newPairingState -&gt;&#10;            pairingState = newPairingState&#10;        }&#10;    )&#10;&#10;    // This effect will handle the connection and notify when the state changes&#10;    BLEConnectEffect(device = device) {&#10;        // update our state to recompose the UI&#10;        state = it&#10;&#10;        // If we get authentication/encryption errors, try to pair the device&#10;        if (it.gatt != null) {&#10;            // Check if we need to pair the device&#10;            val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;            if (!isDevicePaired(adapter, device.address) &amp;&amp; pairingState.state != PairingState.PAIRING) {&#10;                Timber.i(&quot;Device not paired, initiating pairing process&quot;)&#10;                scope.launch {&#10;                    initiateBluetoothPairing(device)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        Text(text = &quot;Device Details&quot;, style = MaterialTheme.typography.headlineSmall)&#10;        Text(text = &quot;Name: ${device.name} (${device.address})&quot;)&#10;&#10;        // Show pairing status&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(text = &quot;Pairing Status:&quot;)&#10;            Text(&#10;                text = when (pairingState.state) {&#10;                    PairingState.NOT_PAIRED -&gt; &quot;Not Paired&quot;&#10;                    PairingState.PAIRING -&gt; &quot;Pairing...&quot;&#10;                    PairingState.PAIRED -&gt; &quot;Paired âœ“&quot;&#10;                    PairingState.PAIRING_FAILED -&gt; &quot;Failed&quot;&#10;                },&#10;                color = when (pairingState.state) {&#10;                    PairingState.PAIRED -&gt; MaterialTheme.colorScheme.primary&#10;                    PairingState.PAIRING_FAILED -&gt; MaterialTheme.colorScheme.error&#10;                    else -&gt; MaterialTheme.colorScheme.onSurface&#10;                }&#10;            )&#10;        }&#10;&#10;        // Show pairing error if any&#10;        pairingState.errorMessage?.let { error -&gt;&#10;            Text(&#10;                text = &quot;Pairing Error: $error&quot;,&#10;                color = MaterialTheme.colorScheme.error,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;        }&#10;&#10;        Text(text = &quot;Connection Status: ${state?.connectionState?.toConnectionStateString()}&quot;)&#10;        Text(text = &quot;MTU: ${state?.mtu}&quot;)&#10;        Text(text = &quot;Services: ${state?.services?.joinToString { it.uuid.toString() + &quot; &quot; + it.type }}&quot;)&#10;        Text(text = &quot;Message sent: ${state?.messageSent}&quot;)&#10;        Text(text = &quot;Message received: ${state?.messageReceived}&quot;)&#10;&#10;        // Manual pairing button&#10;        Button(&#10;            enabled = pairingState.state == PairingState.NOT_PAIRED || pairingState.state == PairingState.PAIRING_FAILED,&#10;            onClick = {&#10;                scope.launch {&#10;                    Timber.i(&quot;Manual pairing initiated for ${device.name}&quot;)&#10;                    initiateBluetoothPairing(device)&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = if (pairingState.state == PairingState.PAIRING) &quot;Pairing...&quot; else &quot;Pair Device&quot;)&#10;        }&#10;        Button(&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    if (state?.connectionState == BluetoothProfile.STATE_DISCONNECTED) {&#10;                        //      state?.gatt?.connect()&#10;                    }&#10;                    // Example on how to request specific MTUs&#10;                    // Note that from Android 14 onwards the system will define a default MTU and&#10;                    // it will only be sent once to the peripheral device&#10;                    state?.gatt?.requestMtu(Random.nextInt(27, 190))&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Request MTU&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    // Once we have the connection discover the peripheral services&#10;                    state?.gatt?.discoverServices()&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Discover&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                /* scope.launch(Dispatchers.IO) {&#10;                     sendData(state?.gatt!!, characteristic!!)&#10;                 }*/&#10;            },&#10;        ) {&#10;            Text(text = &quot;Write to server&quot;)&#10;        }&#10;        Button(&#10;            enabled = state?.gatt != null &amp;&amp; characteristic != null,&#10;            onClick = {&#10;                scope.launch(Dispatchers.IO) {&#10;                    state?.gatt?.readCharacteristic(characteristic)&#10;                }&#10;            },&#10;        ) {&#10;            Text(text = &quot;Read characteristic&quot;)&#10;        }&#10;        Button(onClick = onClose) {&#10;            Text(text = &quot;Close&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;fun set_location(latitude: Double, longitude: Double): ByteArray {&#10;    val myLat = (latitude * 1e7).toInt()&#10;    val myLng = (longitude * 1e7).toInt()&#10;    val myLatByte = ByteBuffer.allocate(4).putInt(myLat).array()&#10;    val myLngByte = ByteBuffer.allocate(4).putInt(myLng).array()&#10;    return myLatByte + myLngByte&#10;}&#10;&#10;fun set_date(zoneId: ZoneId): ByteArray {&#10;    val now = ZonedDateTime.ofInstant(Instant.now(), zoneId)&#10;    val year = now.year.toShort()&#10;    val yearBytes = ByteBuffer.allocate(2).putShort(year).array()&#10;    val hour = now.hour&#10;    return byteArrayOf(&#10;        yearBytes[0], yearBytes[1],&#10;        now.monthValue.toByte(),&#10;        now.dayOfMonth.toByte(),&#10;        now.hour.toByte(),&#10;        now.minute.toByte(),&#10;        now.second.toByte()&#10;    )&#10;}&#10;&#10;&#10;@Composable&#10;private fun DevicesScreen(&#10;    deviceManager: CompanionDeviceManager,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    val context = LocalContext.current&#10;    var associatedDevices by remember {&#10;        // If we already associated the device no need to do it again.&#10;        mutableStateOf(deviceManager.getAssociatedDevices())&#10;    }&#10;&#10;        LaunchedEffect(associatedDevices) {&#10;            associatedDevices.forEach { device -&gt;&#10;                Timber.i(&quot;Starting observing device presence for ${device.name} (${device.address})&quot;)&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.BAKLAVA) {&#10;                    deviceManager.startObservingDevicePresence(ObservingDevicePresenceRequest.Builder().setAssociationId(device.id).build())&#10;                } else {&#10;                    deviceManager.startObservingDevicePresence(device.address)&#10;                }&#10;                &#10;                // After starting device presence observation, initiate Bluetooth pairing if not already paired&#10;                scope.launch {&#10;                    val bluetoothManager = context.getSystemService&lt;BluetoothManager&gt;()&#10;                    val adapter = bluetoothManager?.adapter&#10;                    val bluetoothDevice = device.device ?: adapter?.getRemoteDevice(device.address)&#10;                    &#10;                    if (bluetoothDevice != null &amp;&amp; !isDevicePaired(adapter, device.address)) {&#10;                        Timber.i(&quot;Device ${device.name} not paired, initiating pairing after presence observation&quot;)&#10;                        val pairingResult = initiateBluetoothPairing(bluetoothDevice)&#10;                        if (pairingResult) {&#10;                            Timber.i(&quot;Pairing initiated successfully for ${device.name}&quot;)&#10;                        } else {&#10;                            Timber.w(&quot;Failed to initiate pairing for ${device.name}&quot;)&#10;                        }&#10;                    } else if (isDevicePaired(adapter, device.address)) {&#10;                        Timber.i(&quot;Device ${device.name} is already paired&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;        }&#10;&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            Text(&#10;                text = &quot;Sony Camera GPS&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                modifier = Modifier.padding(32.dp),&#10;            )&#10;        }) { innerPadding -&gt;&#10;&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(innerPadding),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;&#10;        ) {&#10;            Button(onClick = {&#10;                context.startActivity(&#10;                    Intent(&#10;                        context,&#10;                        LogViewerActivity::class.java&#10;                    )&#10;                )&#10;            }) { Text(text = &quot;View logs&quot;) }&#10;            ScanForDevicesMenu(deviceManager) {&#10;                associatedDevices = associatedDevices + it&#10;            }&#10;            AssociatedDevicesList(&#10;                associatedDevices = associatedDevices,&#10;                onConnect = onConnect,&#10;                onDisassociate = {&#10;                    scope.launch {&#10;&#10;                        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.BAKLAVA) {&#10;                            deviceManager.stopObservingDevicePresence(&#10;                                ObservingDevicePresenceRequest.Builder().setAssociationId(it.id)&#10;                                    .build()&#10;                            )&#10;&#10;                        } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                            @Suppress(&quot;DEPRECATION&quot;)&#10;                            deviceManager.stopObservingDevicePresence(it.address)&#10;                        }&#10;&#10;                        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                            deviceManager.disassociate(it.id)&#10;                        } else {&#10;                            @Suppress(&quot;DEPRECATION&quot;)&#10;                            deviceManager.disassociate(it.address)&#10;                        }&#10;&#10;&#10;                        associatedDevices = deviceManager.getAssociatedDevices()&#10;                    }&#10;                },&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ScanForDevicesMenu(&#10;    deviceManager: CompanionDeviceManager,&#10;    onDeviceAssociated: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    val scope = rememberCoroutineScope()&#10;    var errorMessage by remember {&#10;        mutableStateOf(&quot;&quot;)&#10;    }&#10;    val launcher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartIntentSenderForResult(),&#10;    ) {&#10;        when (it.resultCode) {&#10;            CompanionDeviceManager.RESULT_OK -&gt; {&#10;                it.data?.getAssociationResult()?.run {&#10;                    onDeviceAssociated(this)&#10;                }&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_CANCELED -&gt; {&#10;                errorMessage = &quot;The request was canceled&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_INTERNAL_ERROR -&gt; {&#10;                errorMessage = &quot;Internal error happened&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_DISCOVERY_TIMEOUT -&gt; {&#10;                errorMessage = &quot;No device matching the given filter were found&quot;&#10;            }&#10;&#10;            CompanionDeviceManager.RESULT_USER_REJECTED -&gt; {&#10;                errorMessage = &quot;The user explicitly declined the request&quot;&#10;            }&#10;&#10;            else -&gt; {&#10;                errorMessage = &quot;Unknown error&quot;&#10;            }&#10;        }&#10;    }&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(MaterialTheme.colorScheme.primaryContainer)&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;    ) {&#10;        Row {&#10;            Text(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .weight(1f),&#10;                text = stringResource(R.string.scan_for_devices),&#10;            )&#10;            Button(&#10;                modifier = Modifier.weight(0.3f),&#10;                onClick = {&#10;                    scope.launch {&#10;                        val intentSender = requestDeviceAssociation(deviceManager)&#10;                        launcher.launch(IntentSenderRequest.Builder(intentSender).build())&#10;                    }&#10;                },&#10;            ) {&#10;                Text(text = &quot;Start&quot;)&#10;            }&#10;        }&#10;        if (errorMessage.isNotBlank()) {&#10;            Text(text = errorMessage, color = MaterialTheme.colorScheme.error)&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;private fun AssociatedDevicesList(&#10;    associatedDevices: List&lt;AssociatedDeviceCompat&gt;,&#10;    onConnect: (AssociatedDeviceCompat) -&gt; Unit,&#10;    onDisassociate: (AssociatedDeviceCompat) -&gt; Unit,&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(horizontal = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;        stickyHeader {&#10;            Text(&#10;                text = &quot;Associated Devices:&quot;,&#10;                modifier = Modifier.padding(vertical = 8.dp),&#10;                style = MaterialTheme.typography.titleMedium,&#10;            )&#10;        }&#10;        items(associatedDevices) { device -&gt;&#10;            Row(&#10;                Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically,&#10;            ) {&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(1f),&#10;                ) {&#10;                    Text(text = &quot;ID: ${device.id}&quot;)&#10;                    Text(text = &quot;MAC: ${device.address}&quot;)&#10;                    Text(text = &quot;Name: ${device.name}&quot;)&#10;                }&#10;                Column(&#10;                    Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(0.6f),&#10;                    horizontalAlignment = Alignment.End,&#10;                    verticalArrangement = Arrangement.Center,&#10;                ) {&#10;                    OutlinedButton(&#10;                        onClick = { onConnect(device) },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                    ) {&#10;                        Text(text = &quot;Connect&quot;)&#10;                    }&#10;                    OutlinedButton(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        onClick = { onDisassociate(device) },&#10;                        border = ButtonDefaults.outlinedButtonBorder().copy(&#10;                            brush = SolidColor(MaterialTheme.colorScheme.error),&#10;                        ),&#10;                    ) {&#10;                        Text(text = &quot;Disassociate&quot;, color = MaterialTheme.colorScheme.error)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun Intent.getAssociationResult(): AssociatedDeviceCompat? {&#10;    var result: AssociatedDeviceCompat? = null&#10;&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;        result = getParcelableExtra(&#10;            CompanionDeviceManager.EXTRA_ASSOCIATION,&#10;            AssociationInfo::class.java,&#10;        )?.toAssociatedDevice()&#10;    } else {&#10;        // Below Android 33 the result returns either a BLE ScanResult, a&#10;        // Classic BluetoothDevice or a Wifi ScanResult&#10;        // In our case we are looking for our BLE GATT server so we can cast directly&#10;        // to the BLE ScanResult&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        val scanResult = getParcelableExtra&lt;ScanResult&gt;(CompanionDeviceManager.EXTRA_DEVICE)&#10;        if (scanResult != null) {&#10;            result = AssociatedDeviceCompat(&#10;                id = scanResult.advertisingSid,&#10;                address = scanResult.device.address ?: &quot;N/A&quot;,&#10;                name = scanResult.scanRecord?.deviceName ?: &quot;N/A&quot;,&#10;                device = scanResult.device,&#10;            )&#10;        }&#10;    }&#10;    return result&#10;&#10;}&#10;&#10;private suspend fun requestDeviceAssociation(deviceManager: CompanionDeviceManager): IntentSender {&#10;    // Match only Bluetooth devices whose service UUID matches this pattern.&#10;    // For this demo we will match our GATTServerSample&#10;    val deviceFilter = BluetoothLeDeviceFilter.Builder()&#10;        .setNamePattern(Pattern.compile(&quot;ILCE&quot;))&#10;        .build()&#10;&#10;    val pairingRequest: AssociationRequest = AssociationRequest.Builder()&#10;        // Find only devices that match this request filter.&#10;        .addDeviceFilter(deviceFilter)&#10;        // Stop scanning as soon as one device matching the filter is found.&#10;      //  .setSingleDevice(true)&#10;        .build()&#10;&#10;    val result = CompletableDeferred&lt;IntentSender&gt;()&#10;&#10;    val callback = object : CompanionDeviceManager.Callback() {&#10;        override fun onAssociationPending(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        @Suppress(&quot;OVERRIDE_DEPRECATION&quot;)&#10;        override fun onDeviceFound(intentSender: IntentSender) {&#10;            result.complete(intentSender)&#10;        }&#10;&#10;        override fun onAssociationCreated(associationInfo: AssociationInfo) {&#10;&#10;            Timber.i(&quot;Association created: ${associationInfo.displayName} (${associationInfo.id})&quot;)&#10;            // If you want to start observing the device presence you can do it here.&#10;            // This will allow you to receive events when the device is nearby or not.&#10;            // Note that this is only available in API 34 and above.&#10;        /*    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.BAKLAVA) {&#10;                deviceManager.startObservingDevicePresence(&#10;                    ObservingDevicePresenceRequest.Builder().setAssociationId(associationInfo.id)&#10;                        .build()&#10;                )&#10;            } else {&#10;                deviceManager.myAssociations.stream().filter { it -&gt; it.id == associationInfo. }&#10;                deviceManager.startOmyAssociationsbservingDevicePresence(it.toAssociatedDevice().address)&#10;            }*/&#10;            // This callback was added in API 33 but the result is also send in the activity result.&#10;            // For handling backwards compatibility we can just have all the logic there instead&#10;        }&#10;&#10;        override fun onFailure(errorMessage: CharSequence?) {&#10;            result.completeExceptionally(IllegalStateException(errorMessage?.toString().orEmpty()))&#10;        }&#10;    }&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;        val executor = Executor { it.run() }&#10;        deviceManager.associate(pairingRequest, executor, callback)&#10;    } else {&#10;        deviceManager.associate(pairingRequest, callback, null)&#10;    }&#10;&#10;    return result.await()&#10;}&#10;&#10;// Bluetooth pairing state and functionality&#10;enum class PairingState {&#10;    NOT_PAIRED,&#10;    PAIRING,&#10;    PAIRED,&#10;    PAIRING_FAILED&#10;}&#10;&#10;data class BluetoothPairingState(&#10;    val state: PairingState = PairingState.NOT_PAIRED,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;@RequiresPermission(allOf = [Manifest.permission.BLUETOOTH_CONNECT])&#10;fun isDevicePaired(adapter: BluetoothAdapter?, deviceAddress: String): Boolean {&#10;    return adapter?.bondedDevices?.any { it.address == deviceAddress } ?: false&#10;}&#10;&#10;@RequiresPermission(allOf = [Manifest.permission.BLUETOOTH_CONNECT])&#10;fun initiateBluetoothPairing(device: BluetoothDevice): Boolean {&#10;    return try {&#10;        device.createBond()&#10;    } catch (e: SecurityException) {&#10;        Timber.e(e, &quot;Failed to initiate pairing due to security exception&quot;)&#10;        false&#10;    } catch (e: Exception) {&#10;        Timber.e(e, &quot;Failed to initiate pairing&quot;)&#10;        false&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BluetoothPairingEffect(&#10;    device: BluetoothDevice,&#10;    onPairingStateChange: (BluetoothPairingState) -&gt; Unit,&#10;    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current&#10;) {&#10;    val context = LocalContext.current&#10;    val currentOnPairingStateChange by rememberUpdatedState(onPairingStateChange)&#10;&#10;    DisposableEffect(device, lifecycleOwner) {&#10;        var pairingState by mutableStateOf(BluetoothPairingState())&#10;&#10;        val pairingReceiver = object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                when (intent?.action) {&#10;                    BluetoothDevice.ACTION_BOND_STATE_CHANGED -&gt; {&#10;                        val bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE)&#10;                        val bondedDevice = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                            intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE, BluetoothDevice::class.java)&#10;                        } else {&#10;                            @Suppress(&quot;DEPRECATION&quot;)&#10;                            intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)&#10;                        }&#10;&#10;                        if (bondedDevice?.address == device.address) {&#10;                            when (bondState) {&#10;                                BluetoothDevice.BOND_BONDING -&gt; {&#10;                                    pairingState = BluetoothPairingState(PairingState.PAIRING)&#10;                                    currentOnPairingStateChange(pairingState)&#10;                                    Timber.i(&quot;Bluetooth pairing in progress with ${device.name}&quot;)&#10;                                }&#10;                                BluetoothDevice.BOND_BONDED -&gt; {&#10;                                    pairingState = BluetoothPairingState(PairingState.PAIRED)&#10;                                    currentOnPairingStateChange(pairingState)&#10;                                    Timber.i(&quot;Bluetooth pairing successful with ${device.name}&quot;)&#10;                                }&#10;                                BluetoothDevice.BOND_NONE -&gt; {&#10;                                    pairingState = BluetoothPairingState(&#10;                                        PairingState.PAIRING_FAILED,&#10;                                        &quot;Pairing failed or bond was removed&quot;&#10;                                    )&#10;                                    currentOnPairingStateChange(pairingState)&#10;                                    Timber.w(&quot;Bluetooth pairing failed with ${device.name}&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        val filter = IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED)&#10;        context.registerReceiver(pairingReceiver, filter)&#10;&#10;        // Check initial pairing state&#10;        val adapter = context.getSystemService&lt;BluetoothManager&gt;()?.adapter&#10;        val isAlreadyPaired = isDevicePaired(adapter, device.address)&#10;        if (isAlreadyPaired) {&#10;            pairingState = BluetoothPairingState(PairingState.PAIRED)&#10;            currentOnPairingStateChange(pairingState)&#10;        } else {&#10;            pairingState = BluetoothPairingState(PairingState.NOT_PAIRED)&#10;            currentOnPairingStateChange(pairingState)&#10;        }&#10;&#10;        onDispose {&#10;            context.unregisterReceiver(pairingReceiver)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>